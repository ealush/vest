{"version":3,"file":"vest.min.js","sources":["../src/core/Context/index.js","../src/core/test/lib/TestObject/index.js","../node_modules/n4s/dist/enforce.min.js","../node_modules/anyone/any/index.js","../src/lib/throwError/index.js","../src/lib/singleton/index.js","../src/hooks/exclusive/index.js","../src/core/test/index.js","../src/core/suiteResult/index.js","../src/index.js","../src/hooks/draft/index.js","../src/core/validate/index.js","../src/hooks/warn/index.js"],"sourcesContent":["import { singleton } from '../../lib';\n\n/**\n * Creates a new context object, and assigns it as a static property on Vest's singleton.\n * @param {Object} parent   Parent context.\n */\nfunction Context(parent) {\n    singleton.use().ctx = this;\n    Object.assign(this, parent);\n}\n\n/**\n * Sets a testObject reference on context.\n * @param {TestObject} A TestObject instance.\n */\nContext.prototype.setCurrentTest = function(testObject) {\n    this.currentTest = testObject;\n};\n\n/**\n * Removes current test from context.\n */\nContext.prototype.removeCurrentTest = function() {\n    delete this.currentTest;\n};\n\n/**\n * Clears stored instance from constructor function.\n */\nContext.clear = function() {\n    singleton.use().ctx = null;\n};\n\nexport default Context;\n","/**\n * Describes a test call inside a Vest suite.\n * @param {Object} ctx                  Parent context.\n * @param {String} fieldName            Name of the field being tested.\n * @param {String} statement            The message returned when failing.\n * @param {Promise|Function} testFn     The actual test callbrack or promise.\n */\nfunction TestObject(ctx, fieldName, statement, testFn) {\n    Object.assign(this, {\n        ctx,\n        testFn,\n        fieldName,\n        statement,\n        isWarning: false,\n        failed: false\n    });\n}\n\n/**\n * @returns {Boolean} Current validity status of a test.\n */\nTestObject.prototype.valueOf = function() {\n    return this.failed !== true;\n};\n\n/**\n * Sets a test to failed.\n * @returns {TestObject} Current instance.\n */\nTestObject.prototype.fail = function() {\n    this.ctx.result.markFailure({\n        fieldName: this.fieldName,\n        statement: this.statement,\n        isWarning: this.isWarning\n    });\n\n    this.failed = true;\n    return this;\n};\n\n/**\n * Sets a current test's `isWarning` to true.\n * @returns {TestObject} Current instance.\n */\nTestObject.prototype.warn = function() {\n    this.isWarning = true;\n    return this;\n};\n\nexport default TestObject;\n","\"use strict\";!function(e,t){\"object\"==typeof exports&&\"undefined\"!=typeof module?module.exports=t():\"function\"==typeof define&&define.amd?define(t):(e=e||self).enforce=t()}(this,(function(){function e(e){return!!Array.isArray(e)}function t(e){return\"number\"==typeof e}function n(e){return\"string\"==typeof e}function r(e,t){return t instanceof RegExp?t.test(e):\"string\"==typeof t&&new RegExp(t).test(e)}function o(e,t){return!!(Array.isArray(t)&&[\"string\",\"number\",\"boolean\"].includes(typeof e)||\"string\"==typeof t&&\"string\"==typeof e)&&t.includes(e)}function i(e,t){return e===t}function u(e){return!(isNaN(parseFloat(e))||isNaN(Number(e))||!isFinite(e))}function s(e,t){return u(e)&&u(t)&&Number(e)===Number(t)}function a(e){return!e||(u(e)?0===e:Object.prototype.hasOwnProperty.call(e,\"length\")?0===e.length:\"object\"!=typeof e||0===Object.keys(e).length)}function f(e,t){return u(e)&&u(t)&&Number(e)>Number(t)}function c(e,t){return u(e)&&u(t)&&Number(e)>=Number(t)}function l(e,t){return u(e)&&u(t)&&Number(e)<Number(t)}function g(e,t){return u(e)&&u(t)&&Number(e)<=Number(t)}function m(e,t){return e.length===t}function y(e){return!!e}function h(e,t,...n){if(\"function\"==typeof e&&!0!==e(t,...n))throw Error(`[Enforce]: invalid ${typeof t} value`)}function p(e={}){let t={...d,...e};if(\"function\"==typeof N.Proxy)return e=>{let n=new Proxy(t,{get:(t,r)=>{if(b(t,r))return(...o)=>(h(t[r],e,...o),n)}});return n};let n=Object.keys(t);return e=>n.reduce((n,r)=>Object.assign(n,{...b(t,r)&&{[r]:(...o)=>(h(t[r],e,...o),n)}}),{})}let b=(e,t)=>((e=Object.prototype.hasOwnProperty.call(e,t)&&\"function\"==typeof e[t])||function(e){setTimeout(()=>{throw Error(`[enforce]: ${e}`)})}(`Rule \"${t}\" was not found in rules object. Make sure you typed it correctly.`),e),N=Function(\"return this\")();e.negativeForm=\"isNotArray\",t.negativeForm=\"isNotNumber\",n.negativeForm=\"isNotString\",r.negativeForm=\"notMatches\",o.negativeForm=\"notInside\",i.negativeForm=\"notEquals\",u.negativeForm=\"isNotNumeric\",s.negativeForm=\"numberNotEquals\",a.negativeForm=\"isNotEmpty\",f.alias=\"gt\",c.alias=\"gte\",l.alias=\"lt\",g.alias=\"lte\",m.negativeForm=\"lengthNotEquals\",y.negativeForm=\"isFalsy\";var d=function(e){for(let t in e){let n=e[t].negativeForm,r=e[t].alias;n&&(e[n]=(...n)=>!e[t](...n)),r&&(e[r]=e[t])}return e}({isArray:e,isNumber:t,isString:n,matches:r,inside:o,equals:i,numberEquals:s,isNumeric:u,isEmpty:a,greaterThan:f,greaterThanOrEquals:c,lessThan:l,lessThanOrEquals:g,longerThan:function(e,t){return e.length>t},longerThanOrEquals:function(e,t){return e.length>=t},shorterThan:function(e,t){return e.length<t},shorterThanOrEquals:function(e,t){return e.length<=t},lengthEquals:m,isOdd:e=>!!u(e)&&0!=e%2,isEven:e=>!!u(e)&&0==e%2,isTruthy:y});let E=new p;return E.Enforce=p,E}));\n","'use strict';(function(c,b){\"object\"===typeof exports&&\"undefined\"!==typeof module?module.exports=b():\"function\"===typeof define&&define.amd?define(b):(c=c||self,c.any=b())})(this,function(){let c=a=>{if(\"function\"===typeof a)try{return b(a())}catch(d){return!1}return b(a)},b=a=>Array.isArray(a)?!0:0!=a&&!!a;return(...a)=>a.some(c)})\n","/**\n * Throws a timed out error.\n * @param {String} message  Error message to display.\n * @param {Error} [type]    Alternative Error type.\n */\nconst throwError = (message, type = Error) => setTimeout(() => {\n    throw new type(`[Vest]: ${message}`);\n});\n\nexport default throwError;\n","import throwError from '../throwError';\nimport go from '../globalObject';\nimport { SYMBOL_VEST } from './constants';\n\n/**\n * Throws an error when multiple versions of Vest are detected on the same runtime.\n * @param  {String[]} versions List of detected Vest versions.\n */\nconst throwMultipleVestError = (...versions) => {\n    throwError(`Multiple versions of Vest detected: (${versions.join()}).\n    Most features should work regularly, but for optimal feature compatibility, you should have all running instances use the same version.`);\n};\n\n/**\n * Registers current Vest instance on global object.\n * @param {Object} vest Reference to Vest.\n * @return {Function} Global Vest reference.\n */\nconst register = (vest) => {\n\n    const existing = go[SYMBOL_VEST];\n\n    if (existing) {\n        if (existing.VERSION !== vest.VERSION) {\n            throwMultipleVestError(vest.VERSION, existing.VERSION);\n        }\n    } else {\n        go[SYMBOL_VEST] = vest;\n    }\n\n    return go[SYMBOL_VEST];\n};\n\n/**\n * @returns Global Vest instance.\n */\nconst use = () => go[SYMBOL_VEST];\n\n/**\n * @returns Current Vest context.\n */\nconst useContext = () => use().ctx;\n\nexport default {\n    use,\n    useContext,\n    register\n};\n","import { singleton, throwError } from '../../lib';\nimport { ERROR_HOOK_CALLED_OUTSIDE } from '../constants';\nimport { GROUP_NAME_ONLY, GROUP_NAME_SKIP } from './constants';\n\n/**\n * Adds fields to a specified group.\n * @param {String} group            To add the fields to.\n * @param {String[]|String} item    A field name or a list of field names.\n */\nconst addTo = (group, item) => {\n    const ctx = singleton.useContext();\n\n    if (!item) {\n        return;\n    }\n\n    if (!ctx) {\n        throwError(`${group} ${ERROR_HOOK_CALLED_OUTSIDE}`);\n        return;\n    }\n\n    ctx.exclusive = ctx.exclusive || {};\n\n    [].concat(item).forEach((fieldName) => {\n        if (typeof fieldName === 'string') {\n            ctx.exclusive[group] = ctx.exclusive[group] || {};\n            ctx.exclusive[group][fieldName] = true;\n        }\n    });\n};\n\n/**\n * Adds a field or multiple fields to inclusion group.\n * @param {String[]|String} item Item to be added to inclusion group.\n */\nexport const only = (item) => addTo(GROUP_NAME_ONLY, item);\n\n/**\n * Adds a field or multiple fields to exlusion group.\n * @param {String[]|String} item Item to be added to exlusion group.\n */\nexport const skip = (item) => addTo(GROUP_NAME_SKIP, item);\n\n/**\n * Checks whether a certain field name is excluded by any of the exclusion groups.\n * @param {String} fieldName    FieldN name to test.\n * @returns {Boolean}\n */\nexport const isExcluded = (fieldName) => {\n    const ctx = singleton.useContext();\n\n    if (!(ctx && ctx.exclusive)) {\n        return false;\n    }\n\n    if (\n        ctx.exclusive[GROUP_NAME_SKIP] &&\n        ctx.exclusive[GROUP_NAME_SKIP][fieldName]\n    ) {\n\n        return true;\n    }\n\n    if (ctx.exclusive[GROUP_NAME_ONLY]) {\n        if (ctx.exclusive[GROUP_NAME_ONLY][fieldName]) {\n            return false;\n        }\n\n        return true;\n    }\n\n    return false;\n};\n","import { isExcluded } from '../../hooks/exclusive';\nimport { singleton } from '../../lib';\nimport { TestObject } from './lib';\n\n/**\n * Runs async test.\n * @param {TestObject} testObject A TestObject instance.\n */\nexport const runAsync = (testObject) => {\n    const { testFn, statement, ctx } = testObject;\n\n    const done = () => ctx.result.markAsDone(testObject);\n\n    const fail = (rejectionMessage) => {\n        testObject.statement = typeof rejectionMessage === 'string'\n            ? rejectionMessage\n            : statement;\n\n        testObject.fail();\n\n        done();\n    };\n\n    ctx.setCurrentTest(testObject);\n\n    try {\n        testFn.then(done, fail);\n    } catch (e) {\n        fail();\n    }\n\n    ctx.removeCurrentTest();\n};\n\n/**\n * Runs test callback.\n * @param {TestObject} testObject TestObject instance.\n * @returns {*} Result from test callback.\n */\nconst runTest = (testObject) => {\n    let result;\n\n    testObject.ctx.setCurrentTest(testObject);\n\n    try {\n        result = testObject.testFn.apply(testObject);\n    } catch (e) {\n        result = false;\n    }\n\n    testObject.ctx.removeCurrentTest();\n\n    if (result === false) {\n        testObject.fail();\n    }\n\n    return result;\n};\n\n/**\n * Registers test, if async - adds to pending array\n * @param {TestObject} testObject   A TestObject Instance.\n */\nconst register = (testObject) => {\n    const { testFn, ctx, fieldName } = testObject;\n    let isPending = false;\n\n    if (isExcluded(fieldName)) {\n        ctx.result.addToSkipped(fieldName);\n        return;\n    }\n\n    ctx.result.markTestRun(fieldName);\n\n    const result = runTest(testObject);\n\n    if (result && typeof result.then === 'function') {\n        isPending = true;\n\n        testObject.testFn = result;\n    }\n\n    if (isPending) {\n        ctx.result.setPending(testObject);\n    }\n};\n\n/**\n * Test function used by consumer to provide their own validations.\n * @param {String} fieldName            Name of the field to test.\n * @param {String} [statement]          The message returned in case of a failure.\n * @param {function} testFn             The actual test callback.\n * @return {TestObject}                 A TestObject instance.\n */\nconst test = (fieldName, ...args) => {\n    let statement,\n        testFn;\n\n    if (typeof args[0] === 'string') {\n        [statement, testFn] = args;\n    } else if (typeof args[0] === 'function') {\n        [testFn] = args;\n    }\n\n    if (typeof testFn !== 'function') {\n        return;\n    }\n\n    const testObject = new TestObject(\n        singleton.useContext(),\n        fieldName,\n        statement,\n        testFn\n    );\n\n    register(testObject);\n\n    return testObject;\n};\n\nexport default test;\n","const suiteResult = (name) => {\n    const pending = { tests: [] };\n    const doneCallbacks = [];\n    const fieldCallbacks = {};\n    let isAsync = false;\n\n    /**\n     * Adds a testObject to pending list.\n     * @param {Object} testObject\n     */\n    const setPending = (testObject) => {\n        isAsync = true;\n        pending.tests.push(testObject);\n    };\n\n    /**\n     * Clears a testObject from pending list.\n     * @param {Object} testObject\n     */\n    const clearFromPending = (testObject) => {\n        pending.tests = pending.tests\n            .filter((t) => t !== testObject);\n    };\n\n    /**\n     * Checks if a specified field has any remaining tests.\n     * @param {String} fieldName\n     * @returns {Boolean}\n     */\n    const hasRemaining = (fieldName) => {\n        if (!pending.tests.length) {\n            return false;\n        }\n\n        if (fieldName) {\n            return pending.tests\n                .some((testObject) => testObject.fieldName === fieldName);\n        }\n\n        return !!pending.tests.length;\n    };\n\n    /**\n     * Bumps test counters to indicate tests that are being performed\n     * @param {string} fieldName - The name of the field.\n     */\n    const markTestRun = (fieldName) => {\n\n        if (!output.tests[fieldName]) {\n            output.tests[fieldName] = {\n                testCount: 0,\n                errorCount: 0,\n                warnCount: 0\n            };\n\n            output.tested.push(fieldName);\n        }\n\n        output.tests[fieldName].testCount++;\n        output.testCount++;\n    };\n\n    /**\n     * Marks a test as failed.\n     * @param {Object} testData\n     * @param {String} testData.fieldName       Name of field being tested.\n     * @param {String} [testData.statement]     Failure message to display.\n     * @param {Boolean} [testData.isWarning]    Indicates warn only test.\n     */\n    const markFailure = ({ fieldName, statement, isWarning }) => {\n        if (!output.tests[fieldName]) { return; }\n\n        let severityGroup, severityCount;\n\n        if (isWarning) {\n            severityGroup = 'warnings';\n            severityCount = 'warnCount';\n        } else {\n            severityGroup = 'errors';\n            severityCount = 'errorCount';\n        }\n\n        output.tests[fieldName][severityGroup] =\n            output.tests[fieldName][severityGroup] || [];\n\n        if (statement) {\n            output.tests[fieldName][severityGroup].push(statement);\n        }\n\n        output[severityCount]++;\n        output.tests[fieldName][severityCount]++;\n    };\n\n    /**\n     * Uniquely add a field to the `skipped` list\n     * @param {string} fieldName - The name of the field.\n     */\n    const addToSkipped = (fieldName) => {\n        !output.skipped.includes(fieldName) && output.skipped.push(fieldName);\n    };\n\n    /**\n     * Runs callbacks of specified field, or of the whole suite.\n     * @param {String} [fieldName]\n     */\n    const runCallbacks = (fieldName) => {\n        if (!fieldName) {\n            return doneCallbacks.forEach((cb) => cb(output));\n        }\n\n        if (Array.isArray(fieldCallbacks[fieldName])) {\n            return fieldCallbacks[fieldName].forEach((cb) => cb(output));\n        }\n    };\n\n    /**\n     * Removes a field from pending, and runs its callbacks. If all fields are done, runs all callbacks.\n     * @param {Object} testObject a testObject to remove from pending.\n     */\n    const markAsDone = (testObject) => {\n\n        if (output.canceled) {\n            return;\n        }\n\n        if (testObject) {\n            clearFromPending(testObject);\n            if (!hasRemaining(testObject.fieldName)) {\n                runCallbacks(testObject.fieldName);\n            }\n        }\n\n        if (!hasRemaining()) {\n            runCallbacks();\n        }\n    };\n\n    /**\n     * Registers a callback to run once the suite or a specified field finished running.\n     * @param {String} [name] Name of the field to call back after,\n     * @param {Function} callback A callback to run once validation is finished.\n     * @returns {Object} Output object.\n     */\n    const done = (...args) => {\n        const { length, [length-1]: callback, [length-2]: name } = args;\n\n        if (typeof callback !== 'function') {\n            return output;\n        }\n\n        if (!isAsync) {\n            callback(output);\n            return output;\n        }\n\n        if (name && !hasRemaining(name)) {\n            callback(output);\n            return output;\n        }\n\n        if (name) {\n            fieldCallbacks[name] = fieldCallbacks[name] || [];\n            fieldCallbacks[name].push(callback);\n        } else {\n            doneCallbacks.push(callback);\n        }\n\n        return output;\n    };\n\n    /**\n     * cancels done callbacks. They won't invoke when async operations complete\n     */\n    const cancel = () => {\n        output.canceled = true;\n\n        return output;\n    };\n\n    /**\n     * Collects all fields that have an array of specified group in their results.\n     * @param {String} group Group name (warnings or errors).\n     * @returns {Object} Object of array per field.\n     */\n    const collectFailureMessages = (group) => {\n        const collector = {};\n\n        for (const fieldName in output.tests) {\n            if (output.tests[fieldName] &&\n                output.tests[fieldName][group]) {\n                collector[fieldName] = output.tests[fieldName][group];\n            }\n        }\n\n        return collector;\n    };\n\n    /**\n     * Gets all the errors of a field, or of the whole object.\n     * @param {string} fieldName - The name of the field.\n     * @return {array | object} The field's errors, or all errors.\n     */\n    const getErrors = (fieldName) => {\n        if (!fieldName) {\n            return collectFailureMessages('errors');\n        }\n\n        if (output.tests[fieldName].errors) {\n            return output.tests[fieldName].errors;\n        }\n\n        return [];\n    };\n\n    /**\n     * Gets all the warnings of a field, or of the whole object.\n     * @param {string} [fieldName] - The name of the field.\n     * @return {array | object} The field's warnings, or all warnings.\n     */\n    const getWarnings = (fieldName) => {\n        if (!fieldName) {\n            return collectFailureMessages('warnings');\n        }\n\n        if (output.tests[fieldName].warnings) {\n            return output.tests[fieldName].warnings;\n        }\n\n        return [];\n    };\n\n    /**\n     * Checks if a certain field (or the whole suite) has errors.\n     * @param {string} [fieldName]\n     * @return {boolean}\n     */\n    const hasErrors = (fieldName) => {\n        if (!fieldName) {\n            return !!output.errorCount;\n        }\n\n        return Boolean(\n            output.tests[fieldName] &&\n            output.tests[fieldName].errorCount\n        );\n    };\n\n    /**\n     * Checks if a certain field (or the whole suite) has warnings\n     * @param {string} [fieldName]\n     * @return {boolean}\n     */\n    const hasWarnings = (fieldName) => {\n        if (!fieldName) {\n            return !!output.warnCount;\n        }\n\n        return Boolean(\n            output.tests[fieldName] &&\n            output.tests[fieldName].warnCount\n        );\n    };\n\n    const output = {\n        name,\n        errorCount: 0,\n        warnCount: 0,\n        testCount: 0,\n        tests: {},\n        skipped: [],\n        tested: []\n    };\n\n    Object.defineProperties(output, {\n        hasErrors: {\n            value: hasErrors,\n            writable: true,\n            configurable: true,\n            enumerable: false\n        },\n        hasWarnings: {\n            value: hasWarnings,\n            writable: true,\n            configurable: true,\n            enumerable: false\n        },\n        getErrors: {\n            value: getErrors,\n            writable: true,\n            configurable: true,\n            enumerable: false\n        },\n        getWarnings: {\n            value: getWarnings,\n            writable: true,\n            configurable: true,\n            enumerable: false\n        },\n        done: {\n            value: done,\n            writable: true,\n            configurable: true,\n            enumerable: false\n        },\n        cancel: {\n            value: cancel,\n            writable: true,\n            configurable: true,\n            enumerable: false\n        }\n    });\n\n    return {\n        markTestRun,\n        markFailure,\n        setPending,\n        addToSkipped,\n        markAsDone,\n        pending: pending.tests,\n        output\n    };\n};\n\nexport default suiteResult;\n","import enforce from 'n4s/dist/enforce.min';\nimport any from 'anyone/any';\nimport validate from './core/validate';\nimport { draft, only, skip, warn } from './hooks';\nimport test from './core/test';\nimport { singleton } from './lib';\nimport { VERSION } from './constants';\n\nexport default singleton.register({\n    Enforce: enforce.Enforce,\n    VERSION,\n    enforce,\n    draft,\n    test,\n    any,\n    validate,\n    only,\n    skip,\n    warn,\n});\n","import { singleton, throwError } from '../../lib';\nimport { ERROR_HOOK_CALLED_OUTSIDE } from '../constants';\n\n/**\n * @returns {Object} Current output object.\n */\nconst draft = () => {\n\n    const ctx = singleton.useContext();\n\n    if (ctx) {\n        return ctx.result.output;\n    }\n\n    throwError('draft ' + ERROR_HOOK_CALLED_OUTSIDE);\n};\n\nexport default draft;\n","import { throwError } from '../../lib';\nimport Context from '../Context';\nimport { runAsync } from '../test';\nimport suiteResult from '../suiteResult';\nimport { SUITE_INIT_ERROR } from './constants';\n\n/**\n * Initializes a validation suite, creates a validation context.\n * @param {String} name     Descriptive name for validation suite.\n * @param {Function} tests  Validation suite body.\n * @returns {Object} Vest output object.\n */\nconst validate = (name, tests) => {\n    if (typeof name !== 'string') {\n        return throwError(SUITE_INIT_ERROR + ' Expected name to be a string.', TypeError);\n    }\n\n    if (typeof tests !== 'function') {\n        return throwError(SUITE_INIT_ERROR + ' Expected tests to be a function.', TypeError);\n    }\n\n    const result = suiteResult(name);\n\n    new Context({ result });\n\n    tests();\n\n    Context.clear();\n\n    [...result.pending].forEach(runAsync);\n\n    return result.output;\n};\n\nexport default validate;\n","import { singleton, throwError } from '../../lib';\nimport { ERROR_HOOK_CALLED_OUTSIDE } from '../constants';\nimport { ERROR_OUTSIDE_OF_TEST } from './constants';\n\n/**\n * Sets a running test to warn only mode.\n */\nconst warn = () => {\n    const ctx = singleton.useContext();\n\n    if (!ctx) {\n        throwError('warn ' + ERROR_HOOK_CALLED_OUTSIDE);\n        return;\n    }\n\n    if (!ctx.currentTest) {\n        throwError(ERROR_OUTSIDE_OF_TEST);\n        return;\n    }\n\n    ctx.currentTest.warn();\n};\n\nexport default warn;\n"],"names":["Context","parent","singleton","this","TestObject","ctx","fieldName","statement","testFn","Object","isWarning","failed","module","e","Array","t","n","r","test","RegExp","o","i","u","isNaN","parseFloat","Number","isFinite","s","a","f","c","l","g","m","y","h","p","d","Proxy","get","b","[object Object]","setTimeout","N","Function","isArray","isNumber","isString","matches","inside","equals","numberEquals","isNumeric","isEmpty","greaterThan","greaterThanOrEquals","lessThan","lessThanOrEquals","longerThan","longerThanOrEquals","shorterThan","shorterThanOrEquals","lengthEquals","isOdd","isEven","isTruthy","E","type","message","use","useContext","register","existing","go","SYMBOL_VEST","vest","throwError","VERSION","Context.prototype.setCurrentTest","testObject","Context.prototype.removeCurrentTest","Context.clear","item","group","TestObject.prototype.valueOf","TestObject.prototype.fail","TestObject.prototype.warn","done","fail","rejectionMessage","doneCallbacks","fieldCallbacks","isAsync","hasRemaining","tests","runCallbacks","cb","output","collectFailureMessages","collector","name","errorCount","warnCount","testCount","skipped","tested","hasErrors","value","writable","configurable","enumerable","hasWarnings","getErrors","getWarnings","args","length","callback","cancel","markTestRun","markFailure","severityGroup","severityCount","setPending","addToSkipped","markAsDone","clearFromPending","pending","Enforce","enforce","draft","k","result","isPending","any","validate","TypeError","suiteResult","runAsync","only","skip","warn"],"mappings":"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"}