{"version":3,"file":"vest.min.js","sources":["../src/core/test/lib/TestObject/index.js","../src/core/Context/index.js","../../../node_modules/anyone/any/index.js","../../../node_modules/n4s/dist/enforce.min.js","../src/lib/globalObject/index.js","../src/lib/throwError/index.js","../src/lib/singleton/constants.js","../src/lib/singleton/index.js","../src/hooks/exclusive/index.js","../src/hooks/constants.js","../src/core/test/index.js","../src/index.js","../src/constants.js","../src/hooks/draft/index.js","../src/core/validate/index.js","../src/core/suiteResult/index.js","../src/hooks/exclusive/constants.js","../src/hooks/warn/index.js","../src/hooks/warn/constants.js"],"sourcesContent":["/**\n * Describes a test call inside a Vest suite.\n * @param {Object} ctx                  Parent context.\n * @param {String} fieldName            Name of the field being tested.\n * @param {String} statement            The message returned when failing.\n * @param {Promise|Function} testFn     The actual test callbrack or promise.\n */\nfunction TestObject(ctx, fieldName, statement, testFn) {\n  Object.assign(this, {\n    ctx,\n    testFn,\n    fieldName,\n    statement,\n    isWarning: false,\n    failed: false,\n  });\n}\n\n/**\n * @returns {Boolean} Current validity status of a test.\n */\nTestObject.prototype.valueOf = function () {\n  return this.failed !== true;\n};\n\n/**\n * Sets a test to failed.\n * @returns {TestObject} Current instance.\n */\nTestObject.prototype.fail = function () {\n  this.ctx.result.markFailure({\n    fieldName: this.fieldName,\n    statement: this.statement,\n    isWarning: this.isWarning,\n  });\n\n  this.failed = true;\n  return this;\n};\n\n/**\n * Sets a current test's `isWarning` to true.\n * @returns {TestObject} Current instance.\n */\nTestObject.prototype.warn = function () {\n  this.isWarning = true;\n  return this;\n};\n\nexport default TestObject;\n","import { singleton } from \"../../lib\";\n\n/**\n * Creates a new context object, and assigns it as a static property on Vest's singleton.\n * @param {Object} parent   Parent context.\n */\nfunction Context(parent) {\n  singleton.use().ctx = this;\n  Object.assign(this, parent);\n}\n\n/**\n * Sets a testObject reference on context.\n * @param {TestObject} A TestObject instance.\n */\nContext.prototype.setCurrentTest = function (testObject) {\n  this.currentTest = testObject;\n};\n\n/**\n * Removes current test from context.\n */\nContext.prototype.removeCurrentTest = function () {\n  delete this.currentTest;\n};\n\n/**\n * Clears stored instance from constructor function.\n */\nContext.clear = function () {\n  singleton.use().ctx = null;\n};\n\nexport default Context;\n","\"use strict\";!function(e,n){\"object\"==typeof exports&&\"undefined\"!=typeof module?module.exports=n():\"function\"==typeof define&&define.amd?define(n):(e=e||self).any=n()}(this,(function(){var e=function(e){if(\"function\"==typeof e)try{return n(e())}catch(e){return!1}return n(e)},n=function(e){return!!Array.isArray(e)||0!=e&&!!e};return function(){for(var n=arguments.length,t=Array(n),r=0;r<n;r++)t[r]=arguments[r];return t.some(e)}}));\n","\"use strict\";!function(n,r){\"object\"==typeof exports&&\"undefined\"!=typeof module?module.exports=r():\"function\"==typeof define&&define.amd?define(r):(n=n||self).enforce=r()}(this,(function(){function n(){return(n=Object.assign||function(n){for(var r=1;r<arguments.length;r++){var t,e=arguments[r];for(t in e)Object.prototype.hasOwnProperty.call(e,t)&&(n[t]=e[t])}return n}).apply(this,arguments)}function r(n){return!!Array.isArray(n)}function t(n){return\"number\"==typeof n}function e(n){return\"string\"==typeof n}function o(n,r){return r instanceof RegExp?r.test(n):\"string\"==typeof r&&new RegExp(r).test(n)}function u(n,r){return!!(Array.isArray(r)&&[\"string\",\"number\",\"boolean\"].includes(typeof n)||\"string\"==typeof r&&\"string\"==typeof n)&&r.includes(n)}function i(n,r){return n===r}function a(n){return!(isNaN(parseFloat(n))||isNaN(Number(n))||!isFinite(n))}function f(n,r){return a(n)&&a(r)&&Number(n)===Number(r)}function c(n){return!n||(a(n)?0===n:Object.prototype.hasOwnProperty.call(n,\"length\")?0===n.length:\"object\"!=typeof n||0===Object.keys(n).length)}function s(n,r){return a(n)&&a(r)&&Number(n)>Number(r)}function l(n,r){return a(n)&&a(r)&&Number(n)>=Number(r)}function y(n,r){return a(n)&&a(r)&&Number(n)<Number(r)}function g(n,r){return a(n)&&a(r)&&Number(n)<=Number(r)}function p(n,r){return n.length===r}function m(n){return!!n}function h(n,r){if(\"function\"==typeof n){for(var t=arguments.length,e=Array(2<t?t-2:0),o=2;o<t;o++)e[o-2]=arguments[o];if(!0!==n.apply(void 0,[r].concat(e)))throw Error(\"[Enforce]: invalid \"+typeof r+\" value\")}}function v(r){void 0===r&&(r={});var t=n({},d,{},r);if(\"function\"==typeof N.Proxy)return function(n){var r=new Proxy(t,{get:function(t,e){if(b(t,e))return function(){for(var o=arguments.length,u=Array(o),i=0;i<o;i++)u[i]=arguments[i];return h.apply(void 0,[t[e],n].concat(u)),r}}});return r};var e=Object.keys(t);return function(r){return e.reduce((function(e,o){var u;return n(e,n({},b(t,o)&&((u={})[o]=function(){for(var n=arguments.length,u=Array(n),i=0;i<n;i++)u[i]=arguments[i];return h.apply(void 0,[t[o],r].concat(u)),e},u)))}),{})}}var b=function(n,r){return(n=Object.prototype.hasOwnProperty.call(n,r)&&\"function\"==typeof n[r])||function(n){setTimeout((function(){throw Error(\"[enforce]: \"+n)}))}('Rule \"'+r+'\" was not found in rules object. Make sure you typed it correctly.'),n},N=Function(\"return this\")();r.negativeForm=\"isNotArray\",t.negativeForm=\"isNotNumber\",e.negativeForm=\"isNotString\",o.negativeForm=\"notMatches\",u.negativeForm=\"notInside\",i.negativeForm=\"notEquals\",a.negativeForm=\"isNotNumeric\",f.negativeForm=\"numberNotEquals\",c.negativeForm=\"isNotEmpty\",s.alias=\"gt\",l.alias=\"gte\",y.alias=\"lt\",g.alias=\"lte\",p.negativeForm=\"lengthNotEquals\",m.negativeForm=\"isFalsy\";var d=function(n){var r,t=function(r){var t=n[r].negativeForm,e=n[r].alias;t&&(n[t]=function(){return!n[r].apply(n,arguments)}),e&&(n[e]=n[r])};for(r in n)t(r);return n}({isArray:r,isNumber:t,isString:e,matches:o,inside:u,equals:i,numberEquals:f,isNumeric:a,isEmpty:c,greaterThan:s,greaterThanOrEquals:l,lessThan:y,lessThanOrEquals:g,longerThan:function(n,r){return n.length>r},longerThanOrEquals:function(n,r){return n.length>=r},shorterThan:function(n,r){return n.length<r},shorterThanOrEquals:function(n,r){return n.length<=r},lengthEquals:p,isOdd:function(n){return!!a(n)&&0!=n%2},isEven:function(n){return!!a(n)&&0==n%2},isTruthy:m}),E=new v;return E.Enforce=v,E}));\n","/**\n * @type {Object} Reference to global object.\n */\nconst globalObject = Function(\"return this\")();\n\nexport default globalObject;\n","/**\n * Throws a timed out error.\n * @param {String} message  Error message to display.\n * @param {Error} [type]    Alternative Error type.\n */\nconst throwError = (message, type = Error) =>\n  setTimeout(() => {\n    throw new type(`[Vest]: ${message}`);\n  });\n\nexport default throwError;\n","/**\n * @type {String} Vest's major version.\n */\nconst VEST_MAJOR = VEST_VERSION.split(\".\")[0];\n\n/**\n * @type {Symbol} Used to store a global instance of Vest.\n */\nexport const SYMBOL_VEST = Symbol.for(`VEST#${VEST_MAJOR}`);\n","import go from \"../globalObject\";\nimport throwError from \"../throwError\";\nimport { SYMBOL_VEST } from \"./constants\";\n\n/**\n * Throws an error when multiple versions of Vest are detected on the same runtime.\n * @param  {String[]} versions List of detected Vest versions.\n */\nconst throwMultipleVestError = (...versions) => {\n  throwError(`Multiple versions of Vest detected: (${versions.join()}).\n    Most features should work regularly, but for optimal feature compatibility, you should have all running instances use the same version.`);\n};\n\n/**\n * Registers current Vest instance on global object.\n * @param {Object} vest Reference to Vest.\n * @return {Function} Global Vest reference.\n */\nconst register = (vest) => {\n  const existing = go[SYMBOL_VEST];\n\n  if (existing) {\n    if (existing.VERSION !== vest.VERSION) {\n      throwMultipleVestError(vest.VERSION, existing.VERSION);\n    }\n  } else {\n    go[SYMBOL_VEST] = vest;\n  }\n\n  return go[SYMBOL_VEST];\n};\n\n/**\n * @returns Global Vest instance.\n */\nconst use = () => go[SYMBOL_VEST];\n\n/**\n * @returns Current Vest context.\n */\nconst useContext = () => use().ctx;\n\nexport default {\n  use,\n  useContext,\n  register,\n};\n","import { singleton, throwError } from \"../../lib\";\nimport { ERROR_HOOK_CALLED_OUTSIDE } from \"../constants\";\nimport { GROUP_NAME_ONLY, GROUP_NAME_SKIP } from \"./constants\";\n\n/**\n * Adds fields to a specified group.\n * @param {String} group            To add the fields to.\n * @param {String[]|String} item    A field name or a list of field names.\n */\nconst addTo = (group, item) => {\n  const ctx = singleton.useContext();\n\n  if (!item) {\n    return;\n  }\n\n  if (!ctx) {\n    throwError(`${group} ${ERROR_HOOK_CALLED_OUTSIDE}`);\n    return;\n  }\n\n  ctx.exclusive = ctx.exclusive || {};\n\n  [].concat(item).forEach((fieldName) => {\n    if (typeof fieldName === \"string\") {\n      ctx.exclusive[group] = ctx.exclusive[group] || {};\n      ctx.exclusive[group][fieldName] = true;\n    }\n  });\n};\n\n/**\n * Adds a field or multiple fields to inclusion group.\n * @param {String[]|String} item Item to be added to inclusion group.\n */\nexport const only = (item) => addTo(GROUP_NAME_ONLY, item);\n\n/**\n * Adds a field or multiple fields to exlusion group.\n * @param {String[]|String} item Item to be added to exlusion group.\n */\nexport const skip = (item) => addTo(GROUP_NAME_SKIP, item);\n\n/**\n * Checks whether a certain field name is excluded by any of the exclusion groups.\n * @param {String} fieldName    FieldN name to test.\n * @returns {Boolean}\n */\nexport const isExcluded = (fieldName) => {\n  const ctx = singleton.useContext();\n\n  if (!(ctx && ctx.exclusive)) {\n    return false;\n  }\n\n  if (\n    ctx.exclusive[GROUP_NAME_SKIP] &&\n    ctx.exclusive[GROUP_NAME_SKIP][fieldName]\n  ) {\n    return true;\n  }\n\n  if (ctx.exclusive[GROUP_NAME_ONLY]) {\n    if (ctx.exclusive[GROUP_NAME_ONLY][fieldName]) {\n      return false;\n    }\n\n    return true;\n  }\n\n  return false;\n};\n","/**\n *  @type {String}  Error message to display when a hook was called outside of context.\n */\nexport const ERROR_HOOK_CALLED_OUTSIDE =\n  \"hook called outside of a running suite.\";\n","import { isExcluded } from \"../../hooks/exclusive\";\nimport { singleton } from \"../../lib\";\nimport { TestObject } from \"./lib\";\n\n/**\n * Runs async test.\n * @param {TestObject} testObject A TestObject instance.\n */\nexport const runAsync = (testObject) => {\n  const { testFn, statement, ctx } = testObject;\n\n  const done = () => ctx.result.markAsDone(testObject);\n\n  const fail = (rejectionMessage) => {\n    testObject.statement =\n      typeof rejectionMessage === \"string\" ? rejectionMessage : statement;\n\n    testObject.fail();\n\n    done();\n  };\n\n  ctx.setCurrentTest(testObject);\n\n  try {\n    testFn.then(done, fail);\n  } catch (e) {\n    fail();\n  }\n\n  ctx.removeCurrentTest();\n};\n\n/**\n * Runs test callback.\n * @param {TestObject} testObject TestObject instance.\n * @returns {*} Result from test callback.\n */\nconst runTest = (testObject) => {\n  let result;\n\n  testObject.ctx.setCurrentTest(testObject);\n\n  try {\n    result = testObject.testFn.apply(testObject);\n  } catch (e) {\n    result = false;\n  }\n\n  testObject.ctx.removeCurrentTest();\n\n  if (result === false) {\n    testObject.fail();\n  }\n\n  return result;\n};\n\n/**\n * Registers test, if async - adds to pending array\n * @param {TestObject} testObject   A TestObject Instance.\n */\nconst register = (testObject) => {\n  const { ctx, fieldName } = testObject;\n  let isPending = false;\n\n  if (isExcluded(fieldName)) {\n    ctx.result.addToSkipped(fieldName);\n    return;\n  }\n\n  ctx.result.markTestRun(fieldName);\n\n  const result = runTest(testObject);\n\n  if (result && typeof result.then === \"function\") {\n    isPending = true;\n\n    testObject.testFn = result;\n  }\n\n  if (isPending) {\n    ctx.result.setPending(testObject);\n  }\n};\n\n/**\n * Test function used by consumer to provide their own validations.\n * @param {String} fieldName            Name of the field to test.\n * @param {String} [statement]          The message returned in case of a failure.\n * @param {function} testFn             The actual test callback.\n * @return {TestObject}                 A TestObject instance.\n */\nconst test = (fieldName, ...args) => {\n  let statement, testFn;\n\n  if (typeof args[0] === \"string\") {\n    [statement, testFn] = args;\n  } else if (typeof args[0] === \"function\") {\n    [testFn] = args;\n  }\n\n  if (typeof testFn !== \"function\") {\n    return;\n  }\n\n  const testObject = new TestObject(\n    singleton.useContext(),\n    fieldName,\n    statement,\n    testFn\n  );\n\n  register(testObject);\n\n  return testObject;\n};\n\nexport default test;\n","import any from \"anyone/any\";\nimport enforce from \"n4s/dist/enforce.min\";\nimport { VERSION } from \"./constants\";\nimport test from \"./core/test\";\nimport validate from \"./core/validate\";\nimport { draft, only, skip, warn } from \"./hooks\";\nimport { singleton } from \"./lib\";\n\nexport default singleton.register({\n  Enforce: enforce.Enforce,\n  VERSION,\n  enforce,\n  draft,\n  test,\n  any,\n  validate,\n  only,\n  skip,\n  warn,\n});\n","/**\n * @type {String} Version number derived from current tag.\n */\nexport const VERSION = VEST_VERSION;\n","import { singleton, throwError } from \"../../lib\";\nimport { ERROR_HOOK_CALLED_OUTSIDE } from \"../constants\";\n\n/**\n * @returns {Object} Current output object.\n */\nconst draft = () => {\n  const ctx = singleton.useContext();\n\n  if (ctx) {\n    return ctx.result.output;\n  }\n\n  throwError(\"draft \" + ERROR_HOOK_CALLED_OUTSIDE);\n};\n\nexport default draft;\n","import { throwError } from \"../../lib\";\nimport Context from \"../Context\";\nimport suiteResult from \"../suiteResult\";\nimport { runAsync } from \"../test\";\nimport { SUITE_INIT_ERROR } from \"./constants\";\n\n/**\n * Initializes a validation suite, creates a validation context.\n * @param {String} name     Descriptive name for validation suite.\n * @param {Function} tests  Validation suite body.\n * @returns {Object} Vest output object.\n */\nconst validate = (name, tests) => {\n  if (typeof name !== \"string\") {\n    return throwError(\n      SUITE_INIT_ERROR + \" Expected name to be a string.\",\n      TypeError\n    );\n  }\n\n  if (typeof tests !== \"function\") {\n    return throwError(\n      SUITE_INIT_ERROR + \" Expected tests to be a function.\",\n      TypeError\n    );\n  }\n\n  const result = suiteResult(name);\n\n  new Context({ result });\n\n  tests();\n\n  Context.clear();\n\n  [...result.pending].forEach(runAsync);\n\n  return result.output;\n};\n\nexport default validate;\n","const suiteResult = (name) => {\n  const pending = { tests: [] };\n  const doneCallbacks = [];\n  const fieldCallbacks = {};\n  let isAsync = false;\n\n  /**\n   * Adds a testObject to pending list.\n   * @param {Object} testObject\n   */\n  const setPending = (testObject) => {\n    isAsync = true;\n    pending.tests.push(testObject);\n  };\n\n  /**\n   * Clears a testObject from pending list.\n   * @param {Object} testObject\n   */\n  const clearFromPending = (testObject) => {\n    pending.tests = pending.tests.filter((t) => t !== testObject);\n  };\n\n  /**\n   * Checks if a specified field has any remaining tests.\n   * @param {String} fieldName\n   * @returns {Boolean}\n   */\n  const hasRemaining = (fieldName) => {\n    if (!pending.tests.length) {\n      return false;\n    }\n\n    if (fieldName) {\n      return pending.tests.some(\n        (testObject) => testObject.fieldName === fieldName\n      );\n    }\n\n    return !!pending.tests.length;\n  };\n\n  /**\n   * Bumps test counters to indicate tests that are being performed\n   * @param {string} fieldName - The name of the field.\n   */\n  const markTestRun = (fieldName) => {\n    if (!output.tests[fieldName]) {\n      output.tests[fieldName] = {\n        testCount: 0,\n        errorCount: 0,\n        warnCount: 0,\n      };\n\n      output.tested.push(fieldName);\n    }\n\n    output.tests[fieldName].testCount++;\n    output.testCount++;\n  };\n\n  /**\n   * Marks a test as failed.\n   * @param {Object} testData\n   * @param {String} testData.fieldName       Name of field being tested.\n   * @param {String} [testData.statement]     Failure message to display.\n   * @param {Boolean} [testData.isWarning]    Indicates warn only test.\n   */\n  const markFailure = ({ fieldName, statement, isWarning }) => {\n    if (!output.tests[fieldName]) {\n      return;\n    }\n\n    let severityGroup, severityCount;\n\n    if (isWarning) {\n      severityGroup = \"warnings\";\n      severityCount = \"warnCount\";\n    } else {\n      severityGroup = \"errors\";\n      severityCount = \"errorCount\";\n    }\n\n    output.tests[fieldName][severityGroup] =\n      output.tests[fieldName][severityGroup] || [];\n\n    if (statement) {\n      output.tests[fieldName][severityGroup].push(statement);\n    }\n\n    output[severityCount]++;\n    output.tests[fieldName][severityCount]++;\n  };\n\n  /**\n   * Uniquely add a field to the `skipped` list\n   * @param {string} fieldName - The name of the field.\n   */\n  const addToSkipped = (fieldName) => {\n    !output.skipped.includes(fieldName) && output.skipped.push(fieldName);\n  };\n\n  /**\n   * Runs callbacks of specified field, or of the whole suite.\n   * @param {String} [fieldName]\n   */\n  const runCallbacks = (fieldName) => {\n    if (!fieldName) {\n      return doneCallbacks.forEach((cb) => cb(output));\n    }\n\n    if (Array.isArray(fieldCallbacks[fieldName])) {\n      return fieldCallbacks[fieldName].forEach((cb) => cb(output));\n    }\n  };\n\n  /**\n   * Removes a field from pending, and runs its callbacks. If all fields are done, runs all callbacks.\n   * @param {Object} testObject a testObject to remove from pending.\n   */\n  const markAsDone = (testObject) => {\n    if (output.canceled) {\n      return;\n    }\n\n    if (testObject) {\n      clearFromPending(testObject);\n      if (!hasRemaining(testObject.fieldName)) {\n        runCallbacks(testObject.fieldName);\n      }\n    }\n\n    if (!hasRemaining()) {\n      runCallbacks();\n    }\n  };\n\n  /**\n   * Registers a callback to run once the suite or a specified field finished running.\n   * @param {String} [name] Name of the field to call back after,\n   * @param {Function} callback A callback to run once validation is finished.\n   * @returns {Object} Output object.\n   */\n  const done = (...args) => {\n    const { length, [length - 1]: callback, [length - 2]: name } = args;\n\n    if (typeof callback !== \"function\") {\n      return output;\n    }\n\n    if (!isAsync) {\n      callback(output);\n      return output;\n    }\n\n    if (name && !hasRemaining(name)) {\n      callback(output);\n      return output;\n    }\n\n    if (name) {\n      fieldCallbacks[name] = fieldCallbacks[name] || [];\n      fieldCallbacks[name].push(callback);\n    } else {\n      doneCallbacks.push(callback);\n    }\n\n    return output;\n  };\n\n  /**\n   * cancels done callbacks. They won't invoke when async operations complete\n   */\n  const cancel = () => {\n    output.canceled = true;\n\n    return output;\n  };\n\n  /**\n   * Collects all fields that have an array of specified group in their results.\n   * @param {String} group Group name (warnings or errors).\n   * @returns {Object} Object of array per field.\n   */\n  const collectFailureMessages = (group) => {\n    const collector = {};\n\n    for (const fieldName in output.tests) {\n      if (output.tests[fieldName] && output.tests[fieldName][group]) {\n        collector[fieldName] = output.tests[fieldName][group];\n      }\n    }\n\n    return collector;\n  };\n\n  /**\n   * Gets all the errors of a field, or of the whole object.\n   * @param {string} fieldName - The name of the field.\n   * @return {array | object} The field's errors, or all errors.\n   */\n  const getErrors = (fieldName) => {\n    if (!fieldName) {\n      return collectFailureMessages(\"errors\");\n    }\n\n    if (output.tests[fieldName].errors) {\n      return output.tests[fieldName].errors;\n    }\n\n    return [];\n  };\n\n  /**\n   * Gets all the warnings of a field, or of the whole object.\n   * @param {string} [fieldName] - The name of the field.\n   * @return {array | object} The field's warnings, or all warnings.\n   */\n  const getWarnings = (fieldName) => {\n    if (!fieldName) {\n      return collectFailureMessages(\"warnings\");\n    }\n\n    if (output.tests[fieldName].warnings) {\n      return output.tests[fieldName].warnings;\n    }\n\n    return [];\n  };\n\n  /**\n   * Checks if a certain field (or the whole suite) has errors.\n   * @param {string} [fieldName]\n   * @return {boolean}\n   */\n  const hasErrors = (fieldName) => {\n    if (!fieldName) {\n      return !!output.errorCount;\n    }\n\n    return Boolean(\n      output.tests[fieldName] && output.tests[fieldName].errorCount\n    );\n  };\n\n  /**\n   * Checks if a certain field (or the whole suite) has warnings\n   * @param {string} [fieldName]\n   * @return {boolean}\n   */\n  const hasWarnings = (fieldName) => {\n    if (!fieldName) {\n      return !!output.warnCount;\n    }\n\n    return Boolean(\n      output.tests[fieldName] && output.tests[fieldName].warnCount\n    );\n  };\n\n  const output = {\n    name,\n    errorCount: 0,\n    warnCount: 0,\n    testCount: 0,\n    tests: {},\n    skipped: [],\n    tested: [],\n  };\n\n  Object.defineProperties(output, {\n    hasErrors: {\n      value: hasErrors,\n      writable: true,\n      configurable: true,\n      enumerable: false,\n    },\n    hasWarnings: {\n      value: hasWarnings,\n      writable: true,\n      configurable: true,\n      enumerable: false,\n    },\n    getErrors: {\n      value: getErrors,\n      writable: true,\n      configurable: true,\n      enumerable: false,\n    },\n    getWarnings: {\n      value: getWarnings,\n      writable: true,\n      configurable: true,\n      enumerable: false,\n    },\n    done: {\n      value: done,\n      writable: true,\n      configurable: true,\n      enumerable: false,\n    },\n    cancel: {\n      value: cancel,\n      writable: true,\n      configurable: true,\n      enumerable: false,\n    },\n  });\n\n  return {\n    markTestRun,\n    markFailure,\n    setPending,\n    addToSkipped,\n    markAsDone,\n    pending: pending.tests,\n    output,\n  };\n};\n\nexport default suiteResult;\n","/**\n * @type {String} Exclusivity group name: only.\n */\nexport const GROUP_NAME_ONLY = \"only\";\n\n/**\n * @type {String} Exclusivity group name: skip.\n */\nexport const GROUP_NAME_SKIP = \"skip\";\n","import { singleton, throwError } from \"../../lib\";\nimport { ERROR_HOOK_CALLED_OUTSIDE } from \"../constants\";\nimport { ERROR_OUTSIDE_OF_TEST } from \"./constants\";\n\n/**\n * Sets a running test to warn only mode.\n */\nconst warn = () => {\n  const ctx = singleton.useContext();\n\n  if (!ctx) {\n    throwError(\"warn \" + ERROR_HOOK_CALLED_OUTSIDE);\n    return;\n  }\n\n  if (!ctx.currentTest) {\n    throwError(ERROR_OUTSIDE_OF_TEST);\n    return;\n  }\n\n  ctx.currentTest.warn();\n};\n\nexport default warn;\n","/**\n * @type {String} Error message to display when `warn` gets called outside of a test.\n */\nexport const ERROR_OUTSIDE_OF_TEST =\n  \"warn hook called outside of a test callback. It won't have an effect.\";\n"],"names":["TestObject","ctx","fieldName","statement","testFn","this","isWarning","failed","Context","parent","singleton","module","e","n","Array","arguments","t","r","Object","test","RegExp","isNaN","parseFloat","Number","isFinite","a","o","d","Proxy","get","b","u","i","setTimeout","N","Function","isArray","isNumber","isString","matches","inside","equals","numberEquals","f","isNumeric","isEmpty","c","greaterThan","s","greaterThanOrEquals","l","lessThan","y","lessThanOrEquals","g","longerThan","longerThanOrEquals","shorterThan","shorterThanOrEquals","lengthEquals","p","isOdd","isEven","isTruthy","m","E","v","globalObject","throwError","message","type","Error","SYMBOL_VEST","Symbol","VEST_VERSION","use","useContext","register","vest","existing","go","throwMultipleVestError","versions","addTo","group","item","ERROR_HOOK_CALLED_OUTSIDE","TestObject.prototype.valueOf","TestObject.prototype.fail","TestObject.prototype.warn","runAsync","testObject","done","fail","rejectionMessage","Context.prototype.setCurrentTest","Context.prototype.removeCurrentTest","Context.clear","Enforce","enforce","VERSION","draft","args","result","isPending","any","validate","name","tests","SUITE_INIT_ERROR","TypeError","suiteResult","doneCallbacks","fieldCallbacks","isAsync","clearFromPending","pending","hasRemaining","runCallbacks","cb","output","collectFailureMessages","collector","errorCount","warnCount","testCount","skipped","tested","hasErrors","value","writable","configurable","enumerable","hasWarnings","getErrors","getWarnings","length","callback","cancel","markTestRun","markFailure","severityGroup","severityCount","setPending","addToSkipped","markAsDone","only","GROUP_NAME_ONLY","skip","GROUP_NAME_SKIP","warn","ERROR_OUTSIDE_OF_TEST"],"mappings":"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"}